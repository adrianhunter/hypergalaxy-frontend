

helpers = Chart.helpers
Chart.defaults.foo =
  hover: mode: 'label'
  scales:
    xAxes: [ {
      type: 'category'
      categoryPercentage: 0.8
      barPercentage: 0.9
      gridLines: offsetGridLines: true
    } ]
    yAxes: [ { type: 'linear' } ]

# ---
# generated by js2coffee 2.2.0

Chart.controllers.foo = Chart.DatasetController.extend(
  dataElementType: Chart.elements.Rectangle
  initialize: (chart, datasetIndex) ->
    Chart.DatasetController::initialize.call this, chart, datasetIndex
    # Use this to indicate that this is a bar dataset.
    @getMeta().bar = true
    return
  getBarCount: ->
    me = this
    barCount = 0
    helpers.each me.chart.data.datasets, ((dataset, datasetIndex) ->
      meta = me.chart.getDatasetMeta(datasetIndex)
      if meta.bar and me.chart.isDatasetVisible(datasetIndex)
        ++barCount
      return
    ), me
    barCount
  update: (reset) ->
    me = this
    helpers.each me.getMeta().data, ((rectangle, index) ->
      me.updateElement rectangle, index, reset
      return
    ), me
    return
  updateElement: (rectangle, index, reset) ->
    me = this
    meta = me.getMeta()
    xScale = me.getScaleForId(meta.xAxisID)
    yScale = me.getScaleForId(meta.yAxisID)
    yScale.min = yScale.min
    scaleBase = yScale.getBasePixel()
    rectangleElementOptions = me.chart.options.elements.rectangle
    custom = rectangle.custom or {}
    dataset = me.getDataset()
    helpers.extend rectangle,
      _xScale: xScale
      _yScale: yScale
      _datasetIndex: me.index
      _index: index
      _model:
        x: me.calculateBarX(index, me.index)
        y: if reset then scaleBase else me.calculateBarY(index, me.index)
        label: me.chart.data.labels[index]
        datasetLabel: dataset.label
        base: if reset then scaleBase else me.calculateBarBase(me.index, index)
        width: me.calculateBarWidth(index)
        backgroundColor: if custom.backgroundColor then custom.backgroundColor else helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor)
        borderSkipped: if custom.borderSkipped then custom.borderSkipped else rectangleElementOptions.borderSkipped
        borderColor: if custom.borderColor then custom.borderColor else helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor)
        borderWidth: if custom.borderWidth then custom.borderWidth else helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
    rectangle.pivot()
    return
  calculateBarBase: (datasetIndex, index) ->
    me = this
    meta = me.getMeta()
    yScale = me.getScaleForId(meta.yAxisID)
    value = me.getDataset().data[index]
    base = 0
    console.log value
    yScale.getPixelForValue value[1]
    # if yScale.options.stacked
    #   chart = me.chart
    #   datasets = chart.data.datasets
    #   value = datasets[datasetIndex].data[index]
    #   if value < 0
    #     i = 0
    #     while i < datasetIndex
    #       negDS = datasets[i]
    #       negDSMeta = chart.getDatasetMeta(i)
    #       if negDSMeta.bar and negDSMeta.yAxisID == yScale.id and chart.isDatasetVisible(i)
    #         base += if negDS.data[index] < 0 then negDS.data[index] else 0
    #       i++
    #   else
    #     j = 0
    #     while j < datasetIndex
    #       posDS = datasets[j]
    #       posDSMeta = chart.getDatasetMeta(j)
    #       if posDSMeta.bar and posDSMeta.yAxisID == yScale.id and chart.isDatasetVisible(j)
    #         base += if posDS.data[index] > 0 then posDS.data[index] else 0
    #       j++
    #   return yScale.getPixelForValue(base)
    # console.log yScale.getBasePixel()*0.9
    # yScale.getBasePixel()*0.9
  getRuler: (index) ->
    me = this
    meta = me.getMeta()
    xScale = me.getScaleForId(meta.xAxisID)
    datasetCount = me.getBarCount()
    tickWidth = undefined
    if xScale.options.type == 'category'
      tickWidth = xScale.getPixelForTick(index + 1) - xScale.getPixelForTick(index)
    else
      # Average width
      tickWidth = xScale.width / xScale.ticks.length
    categoryWidth = tickWidth * xScale.options.categoryPercentage
    categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2
    fullBarWidth = categoryWidth / datasetCount
    if xScale.ticks.length != me.chart.data.labels.length
      perc = xScale.ticks.length / me.chart.data.labels.length
      fullBarWidth = fullBarWidth * perc
    barWidth = fullBarWidth * xScale.options.barPercentage
    barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage)
    {
      datasetCount: datasetCount
      tickWidth: tickWidth
      categoryWidth: categoryWidth
      categorySpacing: categorySpacing
      fullBarWidth: fullBarWidth
      barWidth: barWidth
      barSpacing: barSpacing
    }
  calculateBarWidth: (index) ->
    xScale = @getScaleForId(@getMeta().xAxisID)
    ruler = @getRuler(index)
    if xScale.options.stacked then ruler.categoryWidth else ruler.barWidth
  getBarIndex: (datasetIndex) ->
    barIndex = 0
    meta = undefined
    j = undefined
    j = 0
    while j < datasetIndex
      meta = @chart.getDatasetMeta(j)
      if meta.bar and @chart.isDatasetVisible(j)
        ++barIndex
      ++j
    barIndex
  calculateBarX: (index, datasetIndex) ->
    me = this
    meta = me.getMeta()
    xScale = me.getScaleForId(meta.xAxisID)
    barIndex = me.getBarIndex(datasetIndex)
    ruler = me.getRuler(index)
    leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo)
    leftTick -= if me.chart.isCombo then ruler.tickWidth / 2 else 0
    # if xScale.options.stacked
    #   return leftTick + ruler.categoryWidth / 2 + ruler.categorySpacing
    leftTick + ruler.barWidth / 2 + ruler.categorySpacing + ruler.barWidth * barIndex + ruler.barSpacing / 2 + ruler.barSpacing * barIndex
  calculateBarY: (index, datasetIndex) ->
    me = this
    meta = me.getMeta()
    yScale = me.getScaleForId(meta.yAxisID)
    value = me.getDataset().data[index]
    # if yScale.options.stacked
    #   sumPos = 0
    #   sumNeg = 0
    #   i = 0
    #   while i < datasetIndex
    #     ds = me.chart.data.datasets[i]
    #     dsMeta = me.chart.getDatasetMeta(i)
    #     if dsMeta.bar and dsMeta.yAxisID == yScale.id and me.chart.isDatasetVisible(i)
    #       if ds.data[index] < 0
    #         sumNeg += ds.data[index] or 0
    #       else
    #         sumPos += ds.data[index] or 0
    #     i++
    #   if value < 0
    #     return yScale.getPixelForValue(sumNeg + value)
    #   else
    #     return yScale.getPixelForValue(sumPos + value)
    yScale.getPixelForValue value[3]
  draw: (ease) ->
    me = this
    easingDecimal = ease or 1
    helpers.each me.getMeta().data, ((rectangle, index) ->
      d = me.getDataset().data[index]
      if d != null and d != undefined and !isNaN(d)
        rectangle.transition(easingDecimal).draw()
      return
    ), me
    return
  setHoverStyle: (rectangle) ->
    dataset = @chart.data.datasets[rectangle._datasetIndex]
    index = rectangle._index
    custom = rectangle.custom or {}
    model = rectangle._model
    model.backgroundColor = if custom.hoverBackgroundColor then custom.hoverBackgroundColor else helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor))
    model.borderColor = if custom.hoverBorderColor then custom.hoverBorderColor else helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor))
    model.borderWidth = if custom.hoverBorderWidth then custom.hoverBorderWidth else helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth)
    return
  removeHoverStyle: (rectangle) ->
    dataset = @chart.data.datasets[rectangle._datasetIndex]
    index = rectangle._index
    custom = rectangle.custom or {}
    model = rectangle._model
    rectangleElementOptions = @chart.options.elements.rectangle
    model.backgroundColor = if custom.backgroundColor then custom.backgroundColor else helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor)
    model.borderColor = if custom.borderColor then custom.borderColor else helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor)
    model.borderWidth = if custom.borderWidth then custom.borderWidth else helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)
    return
)